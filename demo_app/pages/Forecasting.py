# demo_app/pages/Forecasting.py
import sys
from pathlib import Path

# Add sys.path for project root
project_root = Path(__file__).resolve().parent.parent.parent
sys.path.append(str(project_root))

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.figure_factory as ff
from utils import (
    load_price_data,
    load_forecast_signals,
    load_model_performance,
    load_confusion_matrix
)
from marketml.configs import configs

st.set_page_config(layout="wide")
st.title("ðŸ“ˆ Market Forecasting")

# --- 1. Load Data ---
df_price = load_price_data()
if df_price.empty:
    st.error("Failed to load price data. Please check the pipeline and the file `price_data_enriched_v2.csv`.")
    st.stop()

signals_data = load_forecast_signals()
model_perf_df = load_model_performance()

# --- 2. Sidebar Options ---
st.sidebar.header("Analysis Options")

if model_perf_df.empty:
    available_models = ["XGBoost", "RandomForest", "SVM", "LSTM", "Transformer", "ARIMA"]
    st.sidebar.warning("Performance file not found, showing default model list.")
else:
    metric_cols = [col for col in model_perf_df.columns if 'Accuracy' in col or 'F1_Macro' in col]
    available_models = sorted({col.split('_')[0] for col in metric_cols})

if not available_models:
    st.error("No model performance data found.")
    st.info("Please run the pipeline `02_train_forecasting_models` to generate `model_performance_summary.csv`.")
    st.stop()

main_signal_model = configs.SOFT_SIGNAL_MODEL_NAME

available_tickers = sorted(df_price['ticker'].unique())
selected_ticker = st.sidebar.selectbox(
    "Select Ticker",
    available_tickers,
    index=available_tickers.index('AAPL') if 'AAPL' in available_tickers else 0
)

selected_model_for_metrics = st.sidebar.selectbox(
    "Select Model for Metrics",
    available_models,
    index=available_models.index(main_signal_model) if main_signal_model in available_models else 0
)

# --- 3. Data Processing ---
df_ticker_price = df_price[df_price['ticker'] == selected_ticker].copy()

if not signals_data.empty:
    df_ticker_signals = signals_data[signals_data['ticker'] == selected_ticker].copy()
    prob_cols = [c for c in df_ticker_signals.columns if 'prob_' in c]
    if prob_cols:
        df_ticker_signals['predicted_trend'] = df_ticker_signals[prob_cols].idxmax(axis=1).apply(
            lambda x: 1 if 'increase' in x else (-1 if 'decrease' in x else 0)
        )
    else:
        df_ticker_signals['predicted_trend'] = 0
else:
    df_ticker_signals = pd.DataFrame()

# --- 4. Display Results ---
tab1, tab2 = st.tabs(["ðŸ“Š Chart & Signals", "ðŸ§ª Model Evaluation"])

with tab1:
    st.header(f"Visualization of Historical Forecast Results for {selected_ticker}")
    st.info(
        "This chart does not predict future prices. Instead, it displays the forecast signals (â–²/â–¼) "
        "that the model generated in the past (backtesting). This helps visually evaluate the model's performance "
        "by comparing the forecast signals with the actual price movements that occurred."
    )
    st.markdown(f"_Signals are generated by the main model: **{main_signal_model}**._")

    fig = go.Figure()
    fig.add_trace(go.Candlestick(
        x=df_ticker_price['date'], open=df_ticker_price['open'], high=df_ticker_price['high'],
        low=df_ticker_price['low'], close=df_ticker_price['close'], name=f'{selected_ticker} Price'
    ))

    if 'predicted_trend' in df_ticker_signals.columns and not df_ticker_signals.empty:
        merged_price_signal = pd.merge(df_ticker_price, df_ticker_signals, on='date', how='inner')
        up_prices = merged_price_signal[merged_price_signal['predicted_trend'] == 1]
        down_prices = merged_price_signal[merged_price_signal['predicted_trend'] == -1]

        if not up_prices.empty:
            fig.add_trace(go.Scatter(
                x=up_prices['date'], y=up_prices['low'] * 0.98, mode='markers',
                marker=dict(color='green', symbol='triangle-up', size=10), name='Forecast Up (Historical)'
            ))
        if not down_prices.empty:
            fig.add_trace(go.Scatter(
                x=down_prices['date'], y=down_prices['high'] * 1.02, mode='markers',
                marker=dict(color='red', symbol='triangle-down', size=10), name='Forecast Down (Historical)'
            ))

    fig.update_layout(
        title=f"{selected_ticker} Price and Historical Forecast Signals from {main_signal_model}",
        xaxis_title="Date", yaxis_title="Price (USD)", xaxis_rangeslider_visible=False, height=600,
        legend_title="Legend"
    )
    st.plotly_chart(fig, use_container_width=True)

with tab2:
    st.header(f"Model Performance: {selected_model_for_metrics}")
    st.info("Metrics are averaged over multiple cross-validation runs.")
    col1, col2 = st.columns(2)
    with col1:
        st.subheader("Main Metrics Table")
        if not model_perf_df.empty:
            model_metrics = {}
            for metric in ["Accuracy", "F1_Macro", "Precision_Macro", "Recall_Macro"]:
                col_name = f"{selected_model_for_metrics}_{metric}"
                if col_name in model_perf_df.columns:
                    if 'mean' in model_perf_df.index and 'std' in model_perf_df.index:
                        mean_val = model_perf_df.loc['mean', col_name]
                        std_val = model_perf_df.loc['std', col_name]
                        model_metrics[metric] = f"{mean_val:.4f} Â± {std_val:.4f}"
                    else:
                        model_metrics[metric] = "N/A"
            if model_metrics:
                st.table(pd.DataFrame.from_dict(model_metrics, orient='index', columns=['Value']))
            else:
                st.warning(f"No performance data for model {selected_model_for_metrics}.")
        else:
            st.warning("Model performance summary file not found.")
    with col2:
        st.subheader("Confusion Matrix")
        cm_data = load_confusion_matrix(selected_model_for_metrics)
        if cm_data and 'matrix' in cm_data and 'labels' in cm_data:
            matrix = cm_data['matrix']
            labels = cm_data['labels']
            fig_cm = ff.create_annotated_heatmap(
                z=matrix, x=labels, y=labels, colorscale='Blues', showscale=True
            )
            fig_cm.update_layout(
                title_text='<i>Predicted vs. Actual</i>', xaxis_title='Predicted Label', yaxis_title='Actual Label'
            )
            st.plotly_chart(fig_cm, use_container_width=True)
        else:
            st.info(f"No confusion matrix data for model {selected_model_for_metrics}. "
                    f"Please run the pipeline to generate `marketml/results_output/{selected_model_for_metrics.lower()}_confusion_matrix.json`.")
